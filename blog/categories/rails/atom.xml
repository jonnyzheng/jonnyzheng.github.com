<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Jonny Zheng]]></title>
  <link href="http://jonnyzheng.github.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://jonnyzheng.github.com/"/>
  <updated>2012-08-31T17:21:25+08:00</updated>
  <id>http://jonnyzheng.github.com/</id>
  <author>
    <name><![CDATA[Jonny]]></name>
    <email><![CDATA[mars131@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[carrierwave uploader 中传递变量]]></title>
    <link href="http://jonnyzheng.github.com/blog/2012/08/31/carrierwave-pass-params/"/>
    <updated>2012-08-31T16:29:00+08:00</updated>
    <id>http://jonnyzheng.github.com/blog/2012/08/31/carrierwave-pass-params</id>
    <content type="html"><![CDATA[<p>在carrierwave uploader中经常会用到version的功能，一般我们的写法都是在里面写死process的一些参数，比如</p>

<p><code>ruby
  version :small do
    process :resize_to_fill =&gt; [48,48]
  end
</code></p>

<p>但是有的时候可能我们需要动态的传递一些参数进来对图片做相应的操作，比如用户在前端选择图片的头像区域，然后传到后台进行切割，这个时候需要加一个process方法, 下面的crop_area方法通过参数来截取图片中对应的区域。</p>

<p><code>ruby
 def crop_area
    manipulate! do |img|
      ...
    end
  end
</code></p>

<p>但是参数如何传进来成了问题，起初我是在 Uploader里定义了一个可访问的变量,然后在controller里将参数传递给Uploader实例，结果在crop_area里根本就访问不到Uploader里的实例变量，后来看了下源码发现carrierwave的实现逻辑貌似不能用这样的方法。于是用了一个曲线救国的方法，通过Model来传递参数：</p>

<p>```ruby
# model class
# 定义了attr_accessor coords
class User &lt; ActiveRecord::Base
  attr_accessor :coords
  mount_uploader :icon, AvatarUploader
end</p>

<h1 id="controller">controller</h1>
<p># 将参数传递给 @user.coords
def crop_icon
  @user.coords = params[:coords]
  @user.icon = File.open(path)
  @user.save
  redirect_to :action=&gt; ‘basic’
end</p>

<h1 id="uploader">Uploader</h1>
<p># 这里的model就是controller里@user实例,
# 在process 方法中是可以调用到的
 def crop_area
    manipulate! do |img|
      unless model.coords.nil?
        coords = JSON.parse(model.coords)
        img.crop(“#{coords[‘w’]}x#{coords[‘h’]}+#{coords[‘x’]}+#{coords[‘y’]}”)
      end
      img = yield(img) if block_given?
      img
    end
  end
```</p>

<p>所以最后通过在 Model 中设置实例变量解决动态传递参数的问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails 源码学习 1 (Rails 的初始化过程) ]]></title>
    <link href="http://jonnyzheng.github.com/blog/2012/07/15/reading-rails-1/"/>
    <updated>2012-07-15T15:27:00+08:00</updated>
    <id>http://jonnyzheng.github.com/blog/2012/07/15/reading-rails-1</id>
    <content type="html"><![CDATA[<h2 id="rails-bin-">rails bin 文件</h2>
<p>在rails 项目的目录里运行命令就会看到rails命令的路径<code>/usr/bin/rails</code>，其实是一个ruby文件，可以用编辑器打开看看：</p>

<p>```ruby
#!/usr/bin/env ruby
#
# This file was generated by RubyGems.
#
# The application ‘railties’ is installed as part of a gem, and
# this file is here to facilitate running it.
#</p>

<p>require ‘rubygems’</p>

<p>version = “&gt;= 0”</p>

<p>if ARGV.first
  str = ARGV.first
  str = str.dup.force_encoding(“BINARY”) if str.respond_to? :force_encoding
  p str
  if str =~ /\A<em>(.*)</em>\z/
    version = $1
    ARGV.shift
  end
end</p>

<p>gem ‘railties’, version
load Gem.bin_path(‘railties’, ‘rails’, version)
```</p>

<p>该文件做的事情主要是 <code>require rubygems</code>, 然后最后一行 load railties下面的rails，我们可以打印一下到底load了什么东西：</p>

<p><code>ruby
p Gem.bin_path('railties', 'rails', version)
# will out put /*/*/ruby-1.9.3-p194/gems/railties-3.2.7/bin/rails
</code> 
然后就去看看 <code>railties-3.2.7/bin/rails</code> 里面都有什么吧，路径中的版本号只是我自己机器上使用的版本，可能和其他人的不一样，所以下面都会把路径中的版本号去掉。</p>

<h2 id="railtiesbinrails">railties/bin/rails</h2>

<p>这里面也很简单，基本上只是设置环境，</p>

<p>```ruby
#!/usr/bin/env ruby</p>

<p>if File.exists?(File.join(File.expand_path(‘../../..’, <strong>FILE</strong>), ‘.git’))
  railties_path = File.expand_path(‘../../lib’, <strong>FILE</strong>)
  $:.unshift(railties_path)
end
require “rails/cli”
```</p>

<p>最后require了 <code>railties/lib/rails/cli.rb</code> 这个文件:</p>

<h2 id="railtieslibrailsclirb">railties/lib/rails/cli.rb</h2>

<p>```ruby
require ‘rbconfig’
require ‘rails/script_rails_loader’</p>

<h1 id="if-we-are-inside-a-rails-application-this-method-performs-an-exec-and-thus">If we are inside a Rails application this method performs an exec and thus</h1>
<p># the rest of this script is not run.
Rails::ScriptRailsLoader.exec_script_rails!</p>

<p>require ‘rails/ruby_version_check’
Signal.trap(“INT”) { puts; exit(1) }</p>

<p>if ARGV.first == ‘plugin’
  ARGV.shift
  require ‘rails/commands/plugin_new’
else
  require ‘rails/commands/application’
end
```
第一行的rbconfig是ruby standlib, 可以用来知道当前环境ruby的path，第二行引用的就是rails的装载脚本了，下面的 <code>Rails::ScriptRailsLoader.exec_script_rails!</code> 方法就是在里面定义的</p>

<h2 id="railtieslibrailsscriptrailsloaderrb">railties/lib/rails/script_rails_loader.rb</h2>

<p>```ruby
module Rails
  module ScriptRailsLoader
    RUBY = File.join(*RbConfig::CONFIG.values_at(“bindir”, “ruby_install_name”)) + RbConfig::CONFIG[“EXEEXT”]
    SCRIPT_RAILS = File.join(‘script’, ‘rails’)</p>

<pre><code>def self.exec_script_rails!
  cwd = Dir.pwd
  return unless in_rails_application? || in_rails_application_subdirectory?
  exec RUBY, SCRIPT_RAILS, *ARGV if in_rails_application?
  ...	
rescue SystemCallError
  # could not chdir, no problem just return
end

...
</code></pre>

<p>end
end
```</p>

<p>在 <code>self.exec_script_rails</code> 方法里就是真正的调用rails项目里 <code>script/rails</code> 这个文件啦, 这个文件在每个项目里都有的， 让我们再回到项目里看看这个文件</p>

<h2 id="rails--scriptrails">rails 项目中的 script/rails</h2>

<p>```ruby
#!/usr/bin/env ruby
# This command will automatically be run when you run “rails” with Rails 3 gems installed from the root of your application.</p>

<p>APP_PATH = File.expand_path(‘../../config/application’,  <strong>FILE</strong>)
require File.expand_path(‘../../config/boot’,  <strong>FILE</strong>)
require ‘rails/commands’
```
这里require了 项目中的<code>config/boot.rb</code> 文件，它的主要作用是通过Bundle 把Gemfile 里的Gems都引用进来。最后一步 <code>require 'rails/commands'</code> 是真正更具我们输入的命令做执行的地方，比如 <code>rails s</code>,<code>rails c</code>, <code>rails g</code> 都是在这里做的判断。</p>

<h2 id="railtieslibrailscommandsrb">railties/lib/rails/commands.rb</h2>

<p>这里看看 启动server的片段</p>

<p>```ruby
when ‘server’
  # Change to the application’s path if there is no config.ru file in current dir.
  # This allows us to run script/rails server from other directories, but still get
  # the main config.ru and properly set the tmp directory.
  Dir.chdir(File.expand_path(‘../../’, APP_PATH)) unless File.exists?(File.expand_path(“config.ru”))</p>

<p>require ‘rails/commands/server’
  Rails::Server.new.tap { |server|
    # We need to require application after the server sets environment,
    # otherwise the –environment option given to the server won’t propagate.
    require APP_PATH
    Dir.chdir(Rails.application.root)
    server.start
  }
```
这里最主要的就是调用了 	<code>rails/commnads/server</code> 该文件里定义了 server.start 方法。</p>

<h2 id="railtieslibrailscommandsserverrb">railties/lib/rails/commands/server.rb</h2>

<p>这个文件里主要是在 initialize的时候设置sever 的一些参数，再就是start</p>

<p>```ruby
 def start
      url = “#{options[:SSLEnable] ? ‘https’ : ‘http’}://#{options[:Host]}:#{options[:Port]}”
      puts “=&gt; Booting #{ActiveSupport::Inflector.demodulize(server)}”
      puts “=&gt; Rails #{Rails.version} application starting in #{Rails.env} on #{url}”
      puts “=&gt; Call with -d to detach” unless options[:daemonize]
      trap(:INT) { exit }
      puts “=&gt; Ctrl-C to shutdown server” unless options[:daemonize]</p>

<pre><code>  #Create required tmp directories if not found
  %w(cache pids sessions sockets).each do |dir_to_make|
    FileUtils.mkdir_p(Rails.root.join('tmp', dir_to_make))
  end

  super
ensure
  # The '-h' option calls exit before @options is set.
  # If we call 'options' with it unset, we get double help banners.
  puts 'Exiting' unless @options &amp;&amp; options[:daemonize]   end ``` 这时你就知道在 `rails s` 的时候显示的几行文字是从这里打印出来的了，最后他会调用 Rack::Server.start 方法，也就是父类方法.
</code></pre>

<h2 id="actionpacklibactiondispatchrb">actionpack/lib/action_dispatch.rb</h2>

<p>在 <code>server.rb</code> 里还require了 <code>action_dispatch</code>，这个文件在 Gem <code>action_pack</code> 目录下,
文件里引入了大部分rails需要的模块，包括：</p>

<p>```ruby
require ‘active_support’
require ‘active_support/dependencies/autoload’</p>

<p>require ‘action_pack’
require ‘active_model’
require ‘rack’
```
接下来就是rack server了</p>

<h2 id="racklibserverrb">rack/lib/server.rb</h2>

<p>rack 提供了统一的最简单的web server和应用程序之间的接口，所有的应用程序和web server都可以基于这个开发，大大节省了工作量和兼容问题，比如 rails 可以在自带的webserver webrick 跑，也可以在unicorn， thin，passanger 等webserver上跑，因为大家都是基于rack做的实现。</p>
]]></content>
  </entry>
  
</feed>
