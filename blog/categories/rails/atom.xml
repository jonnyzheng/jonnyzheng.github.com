<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Jonny Zheng]]></title>
  <link href="http://jonnyzheng.github.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://jonnyzheng.github.com/"/>
  <updated>2012-09-09T22:47:26+08:00</updated>
  <id>http://jonnyzheng.github.com/</id>
  <author>
    <name><![CDATA[Jonny]]></name>
    <email><![CDATA[mars131@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails 源码学习 2 (Rack and Webrick)]]></title>
    <link href="http://jonnyzheng.github.com/blog/2012/09/09/reading-rails-2/"/>
    <updated>2012-09-09T21:33:00+08:00</updated>
    <id>http://jonnyzheng.github.com/blog/2012/09/09/reading-rails-2</id>
    <content type="html"><![CDATA[<h3 id="rack">先来一个rack程序的简单例子</h3>

<p>```ruby
require ‘rubygems’
require ‘rack’</p>

<p>class HelloWorld
  def call(env)
    return [200, {}, [“Hello world!”]]
  end
end</p>

<p>Rack::Handler::WEBrick.run(HelloWorld.new,:Port =&gt; 9000)
```</p>

<p><code>HelloWorld</code> 方法里定义了一个call方法，call方法只有一个参数env, 方法会return一个数组，里面包含了http请求的response. 运行一下这个文件看看：</p>

<p><code>ruby
$ ruby myserver.rb
[2012-08-24 12:24:28] INFO  WEBrick 1.3.1
[2012-08-24 12:24:28] INFO  ruby 1.9.3 (2012-04-20) [x86_64-darwin11.4.0]
[2012-08-24 12:24:28] INFO  WEBrick::HTTPServer#start: pid=17920 port=9000
</code>
我们通过 WebBrick的run方法启动WebBrick Server, 并且传递了HelloWorld的实例， 现在端口在9000, 打开网页访问 <code>http://localhost:9000</code> 就会看到页面里显示的是 <code>Hello world!</code>.</p>

<h3 id="rackup">rackup</h3>
<p>rack 本身就提供了一个 rackup 工具， 我们可以用rackup工具启动一个文件，不过这个文件要是 .ru后缀结尾的，默认名称是config.ru, 这个文件是不是很眼熟, 其实在每个rails项目的根目录下都有这个文件。让我们来写一个config.ru文件</p>

<p><code>ruby
run Proc.new {|env| [200, {"Content-Type" =&gt; "text/html"}, ["Hello Rack!"]]}
</code></p>

<p>好了，在文件目录里运行一下</p>

<p><code>ruby
$ rackup config.ru
[2012-08-24 14:56:34] INFO  WEBrick 1.3.1
[2012-08-24 14:56:34] INFO  ruby 1.9.3 (2012-04-20) [x86_64-darwin11.4.0]
[2012-08-24 14:56:34] INFO  WEBrick::HTTPServer#start: pid=18286 port=9292
</code> 
这回是绑定在9292端口，rack的默认端口上。</p>

<h3 id="middleware">middleware</h3>

<p>rack 的middleware 提供对任何请求的filter功能，比如我们可以为每次请求记录log, 给每个html页面里加入一些信息，有了middleware接口，
实现起来就非常方便了，而且我们可以堆叠所有的middleware,每一个middleware处理完后传给下一个，直到没有middleware了才会把结果输出出来,
把上面的例子再改一改，为每次输出里面都增加一个字符串：</p>

<p>```ruby
class InsertName
    def initialize(app)
      @app = app
    end</p>

<pre><code>def call(env)
  status, headers, response = @app.call(env)
  [status,headers, [response[0]+ ' jonny']]
end  end
</code></pre>

<p>use InsertName</p>

<p>run Proc.new {|env| [200, {“Content-Type” =&gt; “text/html”}, [“Hello Rack!”]]}
```</p>

<p>重新用rackup启动，访问 localhost:9292， 会看到结果是 <code>Hello Rack! jonny</code></p>

<p>middleware的应用非常灵活强大，rails的很多功能都是基于rack middleware实现的，在rails项目下输入
<code>rack middleware</code> 会列出项目用到的所有middleware, 下面是我的一个项目的middleware列表：</p>

<p><code>ruby
use ActionDispatch::Static
use Rack::Lock
use #&lt;ActiveSupport::Cache::Strategy::LocalCache::Middleware:0x007facbb14adb0&gt;
use Rack::Runtime
use Rack::MethodOverride
use ActionDispatch::RequestId
use Rails::Rack::Logger
use ActionDispatch::ShowExceptions
use ActionDispatch::DebugExceptions
use ActionDispatch::RemoteIp
use ActionDispatch::Reloader
use ActionDispatch::Callbacks
use ActiveRecord::ConnectionAdapters::ConnectionManagement
use ActiveRecord::QueryCache
use ActionDispatch::Cookies
use ActionDispatch::Session::CookieStore
use ActionDispatch::Flash
use ActionDispatch::ParamsParser
use ActionDispatch::Head
use Rack::ConditionalGet
use Rack::ETag
use ActionDispatch::BestStandardsSupport
use Warden::Manager
use OmniAuth::Strategies::Weibo
run Opinion::Application.routes
</code></p>

<h3 id="rack-handler">rack handler</h3>

<p>rack handler 是rack链接server的桥梁，rack 库自带了很多server端的handler, 我们用webrick的handler做示例，在第一个例子里我们就是用的handler启动的Webrick server：
<code>Rack::Handler::WEBrick.run(HelloWorld.new,:Port =&gt; 9000)</code></p>

<ul>
  <li>rack/lib/rack/handler/webrick.rb</li>
</ul>

<p>```ruby
module Rack
  module Handler
    class WEBrick &lt; ::WEBrick::HTTPServlet::AbstractServlet
	  def self.run(app, options={})
        options[:BindAddress] = options.delete(:Host) if options[:Host]
        @server = ::WEBrick::HTTPServer.new(options)
        @server.mount “/”, Rack::Handler::WEBrick, app
        yield @server  if block_given?
        @server.start
      end</p>

<pre><code>  ...
</code></pre>

  	end
<p>end
end
```
WEBrick类是继承于 <code>WEBrick::HTTPServlet::AbstractServlet</code> 这个类的，在 <code>self.run</code> 方法中首先是 new 了一个 WEBrick::HTTPServer，server的mount方法 加载了WEBrick handler类，接下来server处理完block里面的内容后进行启动，看来所有的操作都是 <code>WEBrick::HTTPServer</code> 类完成的，下面就到这个类的源码里看看。</p>

<p>Webrick是ruby的标准函数库，不在gems目录里，我的机器上在 <code>.rvm/rubies/ruby-1.9.3-p194/lib/ruby/1.9.1/webrick</code> 目录下面：</p>

<ul>
  <li>webrick/httpserver.rb</li>
</ul>

<p>```ruby
class HTTPServer &lt; ::WEBrick::GenericServer
    def initialize(config={}, default=Config::HTTP)
      super(config, default)
      @http_version = HTTPVersion::convert(@config[:HTTPVersion])</p>

<pre><code>  @mount_tab = MountTable.new
  if @config[:DocumentRoot]
    mount("/", HTTPServlet::FileHandler, @config[:DocumentRoot],
          @config[:DocumentRootOptions])
  end

  unless @config[:AccessLog]
    @config[:AccessLog] = [
      [ $stderr, AccessLog::COMMON_LOG_FORMAT ],
      [ $stderr, AccessLog::REFERER_LOG_FORMAT ]
    ]
  end

  @virtual_hosts = Array.new
end

... end ```
</code></pre>

<p>父类GenericServer主要做了一些config初始化，端口绑定的工作，mount serverlet 到 相应的路径。</p>

<p>然后看看 <code>start</code> 方法, httpserver里并没有start方法，而是调用了父类的start：</p>

<p>```ruby
def start(&amp;block)
      raise ServerError, “already started.” if @status != :Stop
      server_type = @config[:ServerType] || SimpleServer</p>

<pre><code>  server_type.start{
    @logger.info \
      "#{self.class}#start: pid=#{$$} port=#{@config[:Port]}"
    call_callback(:StartCallback)

    thgroup = ThreadGroup.new
    @status = :Running
    while @status == :Running
      begin
        if svrs = IO.select(@listeners, nil, nil, 2.0)
          svrs[0].each{|svr|
            @tokens.pop          # blocks while no token is there.
            if sock = accept_client(svr)
              sock.do_not_reverse_lookup = config[:DoNotReverseLookup]
              th = start_thread(sock, &amp;block)
              th[:WEBrickThread] = true
              thgroup.add(th)
            else
              @tokens.push(nil)
            end
          }
        end
      rescue Errno::EBADF, IOError =&gt; ex
        # if the listening socket was closed in GenericServer#shutdown,
        # IO::select raise it.
      rescue Exception =&gt; ex
        msg = "#{ex.class}: #{ex.message}\n\t#{ex.backtrace[0]}"
        @logger.error msg
      end
    end

    @logger.info "going to shutdown ..."
    thgroup.list.each{|th| th.join if th[:WEBrickThread] }
    call_callback(:StopCallback)
    @logger.info "#{self.class}#start done."
    @status = :Stop
  } end ```
</code></pre>

<p>start方法内通过@status 状态一直做循环监听，如果有请求就进入处理过程，在start_thread方法中调用httpserver 的 run方法, run方法种初始化了 <code>HTTPResponse</code> 和 <code>HTTPRequest</code> 最后传递给了service方法</p>

<p>```ruby
    def service(req, res)
      if req.unparsed_uri == “*”
        if req.request_method == “OPTIONS”
          do_OPTIONS(req, res)
          raise HTTPStatus::OK
        end
        raise HTTPStatus::NotFound, “`#{req.unparsed_uri}’ not found.”
      end</p>

<pre><code>  servlet, options, script_name, path_info = search_servlet(req.path)
  raise HTTPStatus::NotFound, "`#{req.path}' not found." unless servlet
  req.script_name = script_name
  req.path_info = path_info
  si = servlet.get_instance(self, *options)
  @logger.debug(format("%s is invoked.", si.class.name))
  si.service(req, res)
end ```
</code></pre>

<p>servlet 变量就是之前在webrick handler里mount的类名，在这里取回来后通过 <code>servlet.get_instance</code> 创建了 <code>Rack::Handler::WEBrick</code> 实例，
最终实例调用自己的service方法，我们又回到了 webrick handler 里面：</p>

<p><code>ruby
def service(req, res)
  ...
  status, headers, body = @app.call(env)
  ...
end
</code></p>

<p>在这里我们一开始传进去的app被调用到，并返回对应的内容，到此为止一个request通过rack 再到WebBrick的处理完成.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[carrierwave uploader 中传递变量]]></title>
    <link href="http://jonnyzheng.github.com/blog/2012/08/31/carrierwave-pass-params/"/>
    <updated>2012-08-31T16:29:00+08:00</updated>
    <id>http://jonnyzheng.github.com/blog/2012/08/31/carrierwave-pass-params</id>
    <content type="html"><![CDATA[<p>在carrierwave uploader中经常会用到version的功能，一般我们的写法都是在里面写死process的一些参数，比如</p>

<p><code>ruby
  version :small do
    process :resize_to_fill =&gt; [48,48]
  end
</code></p>

<p>但是有的时候可能我们需要动态的传递一些参数进来对图片做相应的操作，比如用户在前端选择图片的头像区域，然后传到后台进行切割，这个时候需要加一个process方法, 下面的crop_area方法通过参数来截取图片中对应的区域。</p>

<p><code>ruby
 def crop_area
    manipulate! do |img|
      ...
    end
  end
</code></p>

<p>但是参数如何传进来成了问题，起初我是在 Uploader里定义了一个可访问的变量,然后在controller里将参数传递给Uploader实例，结果在crop_area里根本就访问不到Uploader里的实例变量，后来看了下源码发现carrierwave的实现逻辑貌似不能用这样的方法。于是用了一个曲线救国的方法，通过Model来传递参数：</p>

<p>```ruby
# model class
# define attr_accessor coords
class User &lt; ActiveRecord::Base
  attr_accessor :coords
  mount_uploader :icon, AvatarUploader
end</p>

<h1 id="controller">controller</h1>
<p># pass the params to @user.coords
def crop_icon
  @user.coords = params[:coords]
  @user.icon = File.open(path)
  @user.save
  redirect_to :action=&gt; ‘basic’
end</p>

<h1 id="uploader">Uploader</h1>
<p># the model in the function is same as @user in controll,
# and can be invoked inside of process method 
 def crop_area
    manipulate! do |img|
      unless model.coords.nil?
        coords = JSON.parse(model.coords)
        img.crop(“#{coords[‘w’]}x#{coords[‘h’]}+#{coords[‘x’]}+#{coords[‘y’]}”)
      end
      img = yield(img) if block_given?
      img
    end
  end
```</p>

<p>所以最后通过在 Model 中设置实例变量解决动态传递参数的问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails 源码学习 1 (Rails 的初始化过程) ]]></title>
    <link href="http://jonnyzheng.github.com/blog/2012/07/15/reading-rails-1/"/>
    <updated>2012-07-15T15:27:00+08:00</updated>
    <id>http://jonnyzheng.github.com/blog/2012/07/15/reading-rails-1</id>
    <content type="html"><![CDATA[<h2 id="rails-bin-">rails bin 文件</h2>
<p>在rails 项目的目录里运行命令就会看到rails命令的路径<code>/usr/bin/rails</code>，其实是一个ruby文件，可以用编辑器打开看看：</p>

<p>```ruby
#!/usr/bin/env ruby
#
# This file was generated by RubyGems.
#
# The application ‘railties’ is installed as part of a gem, and
# this file is here to facilitate running it.
#</p>

<p>require ‘rubygems’</p>

<p>version = “&gt;= 0”</p>

<p>if ARGV.first
  str = ARGV.first
  str = str.dup.force_encoding(“BINARY”) if str.respond_to? :force_encoding
  p str
  if str =~ /\A<em>(.*)</em>\z/
    version = $1
    ARGV.shift
  end
end</p>

<p>gem ‘railties’, version
load Gem.bin_path(‘railties’, ‘rails’, version)
```</p>

<p>该文件做的事情主要是 <code>require rubygems</code>, 然后最后一行 load railties下面的rails，我们可以打印一下到底load了什么东西：</p>

<p><code>ruby
p Gem.bin_path('railties', 'rails', version)
# will out put /*/*/ruby-1.9.3-p194/gems/railties-3.2.7/bin/rails
</code> 
然后就去看看 <code>railties-3.2.7/bin/rails</code> 里面都有什么吧，路径中的版本号只是我自己机器上使用的版本，可能和其他人的不一样，所以下面都会把路径中的版本号去掉。</p>

<h2 id="railtiesbinrails">railties/bin/rails</h2>

<p>这里面也很简单，基本上只是设置环境，</p>

<p>```ruby
#!/usr/bin/env ruby</p>

<p>if File.exists?(File.join(File.expand_path(‘../../..’, <strong>FILE</strong>), ‘.git’))
  railties_path = File.expand_path(‘../../lib’, <strong>FILE</strong>)
  $:.unshift(railties_path)
end
require “rails/cli”
```</p>

<p>最后require了 <code>railties/lib/rails/cli.rb</code> 这个文件:</p>

<h2 id="railtieslibrailsclirb">railties/lib/rails/cli.rb</h2>

<p>```ruby
require ‘rbconfig’
require ‘rails/script_rails_loader’</p>

<h1 id="if-we-are-inside-a-rails-application-this-method-performs-an-exec-and-thus">If we are inside a Rails application this method performs an exec and thus</h1>
<p># the rest of this script is not run.
Rails::ScriptRailsLoader.exec_script_rails!</p>

<p>require ‘rails/ruby_version_check’
Signal.trap(“INT”) { puts; exit(1) }</p>

<p>if ARGV.first == ‘plugin’
  ARGV.shift
  require ‘rails/commands/plugin_new’
else
  require ‘rails/commands/application’
end
```
第一行的rbconfig是ruby standlib, 可以用来知道当前环境ruby的path，第二行引用的就是rails的装载脚本了，下面的 <code>Rails::ScriptRailsLoader.exec_script_rails!</code> 方法就是在里面定义的</p>

<h2 id="railtieslibrailsscriptrailsloaderrb">railties/lib/rails/script_rails_loader.rb</h2>

<p>```ruby
module Rails
  module ScriptRailsLoader
    RUBY = File.join(*RbConfig::CONFIG.values_at(“bindir”, “ruby_install_name”)) + RbConfig::CONFIG[“EXEEXT”]
    SCRIPT_RAILS = File.join(‘script’, ‘rails’)</p>

<pre><code>def self.exec_script_rails!
  cwd = Dir.pwd
  return unless in_rails_application? || in_rails_application_subdirectory?
  exec RUBY, SCRIPT_RAILS, *ARGV if in_rails_application?
  ...	
rescue SystemCallError
  # could not chdir, no problem just return
end

...
</code></pre>

<p>end
end
```</p>

<p>在 <code>self.exec_script_rails</code> 方法里就是真正的调用rails项目里 <code>script/rails</code> 这个文件啦, 这个文件在每个项目里都有的， 让我们再回到项目里看看这个文件</p>

<h2 id="rails--scriptrails">rails 项目中的 script/rails</h2>

<p>```ruby
#!/usr/bin/env ruby
# This command will automatically be run when you run “rails” with Rails 3 gems installed from the root of your application.</p>

<p>APP_PATH = File.expand_path(‘../../config/application’,  <strong>FILE</strong>)
require File.expand_path(‘../../config/boot’,  <strong>FILE</strong>)
require ‘rails/commands’
```
这里require了 项目中的<code>config/boot.rb</code> 文件，它的主要作用是通过Bundle 把Gemfile 里的Gems都引用进来。最后一步 <code>require 'rails/commands'</code> 是真正更具我们输入的命令做执行的地方，比如 <code>rails s</code>,<code>rails c</code>, <code>rails g</code> 都是在这里做的判断。</p>

<h2 id="railtieslibrailscommandsrb">railties/lib/rails/commands.rb</h2>

<p>这里看看 启动server的片段</p>

<p>```ruby
when ‘server’
  # Change to the application’s path if there is no config.ru file in current dir.
  # This allows us to run script/rails server from other directories, but still get
  # the main config.ru and properly set the tmp directory.
  Dir.chdir(File.expand_path(‘../../’, APP_PATH)) unless File.exists?(File.expand_path(“config.ru”))</p>

<p>require ‘rails/commands/server’
  Rails::Server.new.tap { |server|
    # We need to require application after the server sets environment,
    # otherwise the –environment option given to the server won’t propagate.
    require APP_PATH
    Dir.chdir(Rails.application.root)
    server.start
  }
```
这里最主要的就是调用了 	<code>rails/commnads/server</code> 该文件里定义了 server.start 方法。</p>

<h2 id="railtieslibrailscommandsserverrb">railties/lib/rails/commands/server.rb</h2>

<p>这个文件里主要是在 initialize的时候设置sever 的一些参数，再就是start</p>

<p>```ruby
 def start
      url = “#{options[:SSLEnable] ? ‘https’ : ‘http’}://#{options[:Host]}:#{options[:Port]}”
      puts “=&gt; Booting #{ActiveSupport::Inflector.demodulize(server)}”
      puts “=&gt; Rails #{Rails.version} application starting in #{Rails.env} on #{url}”
      puts “=&gt; Call with -d to detach” unless options[:daemonize]
      trap(:INT) { exit }
      puts “=&gt; Ctrl-C to shutdown server” unless options[:daemonize]</p>

<pre><code>  #Create required tmp directories if not found
  %w(cache pids sessions sockets).each do |dir_to_make|
    FileUtils.mkdir_p(Rails.root.join('tmp', dir_to_make))
  end

  super
ensure
  # The '-h' option calls exit before @options is set.
  # If we call 'options' with it unset, we get double help banners.
  puts 'Exiting' unless @options &amp;&amp; options[:daemonize]   end ``` 这时你就知道在 `rails s` 的时候显示的几行文字是从这里打印出来的了，最后他会调用 Rack::Server.start 方法，也就是父类方法.
</code></pre>

<h2 id="actionpacklibactiondispatchrb">actionpack/lib/action_dispatch.rb</h2>

<p>在 <code>server.rb</code> 里还require了 <code>action_dispatch</code>，这个文件在 Gem <code>action_pack</code> 目录下,
文件里引入了大部分rails需要的模块，包括：</p>

<p>```ruby
require ‘active_support’
require ‘active_support/dependencies/autoload’</p>

<p>require ‘action_pack’
require ‘active_model’
require ‘rack’
```
接下来就是rack server了</p>

<h2 id="racklibserverrb">rack/lib/server.rb</h2>

<p>rack 提供了统一的最简单的web server和应用程序之间的接口，所有的应用程序和web server都可以基于这个开发，大大节省了工作量和兼容问题，比如 rails 可以在自带的webserver webrick 跑，也可以在unicorn， thin，passanger 等webserver上跑，因为大家都是基于rack做的实现。</p>
]]></content>
  </entry>
  
</feed>
