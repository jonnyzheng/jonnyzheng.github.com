<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Jonny Zheng]]></title>
  <link href="http://jonnyzheng.github.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://jonnyzheng.github.com/"/>
  <updated>2012-08-31T15:48:31+08:00</updated>
  <id>http://jonnyzheng.github.com/</id>
  <author>
    <name><![CDATA[Jonny]]></name>
    <email><![CDATA[mars131@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails 源码学习 1 (Rails 的初始化过程) ]]></title>
    <link href="http://jonnyzheng.github.com/blog/2012/07/15/reading-rails-1/"/>
    <updated>2012-07-15T15:27:00+08:00</updated>
    <id>http://jonnyzheng.github.com/blog/2012/07/15/reading-rails-1</id>
    <content type="html"><![CDATA[<h2 id="rails-bin-">rails bin 文件</h2>
<p>在rails 项目的目录里运行命令就会看到rails命令的路径<code>/usr/bin/rails</code>，其实是一个ruby文件，可以用编辑器打开看看：</p>

<p>```ruby
#!/usr/bin/env ruby
#
# This file was generated by RubyGems.
#
# The application ‘railties’ is installed as part of a gem, and
# this file is here to facilitate running it.
#</p>

<p>require ‘rubygems’</p>

<p>version = “&gt;= 0”</p>

<p>if ARGV.first
  str = ARGV.first
  str = str.dup.force_encoding(“BINARY”) if str.respond_to? :force_encoding
  p str
  if str =~ /\A<em>(.*)</em>\z/
    version = $1
    ARGV.shift
  end
end</p>

<p>gem ‘railties’, version
load Gem.bin_path(‘railties’, ‘rails’, version)
```</p>

<p>该文件做的事情主要是 <code>require rubygems</code>, 然后最后一行 load railties下面的rails，我们可以打印一下到底load了什么东西：</p>

<p><code>ruby
p Gem.bin_path('railties', 'rails', version)
# will out put /*/*/ruby-1.9.3-p194/gems/railties-3.2.7/bin/rails
</code> 
然后就去看看 <code>railties-3.2.7/bin/rails</code> 里面都有什么吧，路径中的版本号只是我自己机器上使用的版本，可能和其他人的不一样，所以下面都会把路径中的版本号去掉。</p>

<h2 id="railtiesbinrails">railties/bin/rails</h2>

<p>这里面也很简单，基本上只是设置环境，</p>

<p>```ruby
#!/usr/bin/env ruby</p>

<p>if File.exists?(File.join(File.expand_path(‘../../..’, <strong>FILE</strong>), ‘.git’))
  railties_path = File.expand_path(‘../../lib’, <strong>FILE</strong>)
  $:.unshift(railties_path)
end
require “rails/cli”
```</p>

<p>最后require了 <code>railties/lib/rails/cli.rb</code> 这个文件:</p>

<h2 id="railtieslibrailsclirb">railties/lib/rails/cli.rb</h2>

<p>```ruby
require ‘rbconfig’
require ‘rails/script_rails_loader’</p>

<h1 id="if-we-are-inside-a-rails-application-this-method-performs-an-exec-and-thus">If we are inside a Rails application this method performs an exec and thus</h1>
<p># the rest of this script is not run.
Rails::ScriptRailsLoader.exec_script_rails!</p>

<p>require ‘rails/ruby_version_check’
Signal.trap(“INT”) { puts; exit(1) }</p>

<p>if ARGV.first == ‘plugin’
  ARGV.shift
  require ‘rails/commands/plugin_new’
else
  require ‘rails/commands/application’
end
```
第一行的rbconfig是ruby standlib, 可以用来知道当前环境ruby的path，第二行引用的就是rails的装载脚本了，下面的 <code>Rails::ScriptRailsLoader.exec_script_rails!</code> 方法就是在里面定义的</p>

<h2 id="railtieslibrailsscriptrailsloaderrb">railties/lib/rails/script_rails_loader.rb</h2>

<p>```ruby
module Rails
  module ScriptRailsLoader
    RUBY = File.join(*RbConfig::CONFIG.values_at(“bindir”, “ruby_install_name”)) + RbConfig::CONFIG[“EXEEXT”]
    SCRIPT_RAILS = File.join(‘script’, ‘rails’)</p>

<pre><code>def self.exec_script_rails!
  cwd = Dir.pwd
  return unless in_rails_application? || in_rails_application_subdirectory?
  exec RUBY, SCRIPT_RAILS, *ARGV if in_rails_application?
  ...	
rescue SystemCallError
  # could not chdir, no problem just return
end

...
</code></pre>

<p>end
end
```</p>

<p>在 <code>self.exec_script_rails</code> 方法里就是真正的调用rails项目里 <code>script/rails</code> 这个文件啦, 这个文件在每个项目里都有的， 让我们再回到项目里看看这个文件</p>

<h2 id="rails--scriptrails">rails 项目中的 script/rails</h2>

<p>```ruby
#!/usr/bin/env ruby
# This command will automatically be run when you run “rails” with Rails 3 gems installed from the root of your application.</p>

<p>APP_PATH = File.expand_path(‘../../config/application’,  <strong>FILE</strong>)
require File.expand_path(‘../../config/boot’,  <strong>FILE</strong>)
require ‘rails/commands’
```
这里require了 项目中的<code>config/boot.rb</code> 文件，它的主要作用是通过Bundle 把Gemfile 里的Gems都引用进来。最后一步 <code>require 'rails/commands'</code> 是真正更具我们输入的命令做执行的地方，比如 <code>rails s</code>,<code>rails c</code>, <code>rails g</code> 都是在这里做的判断。</p>

<h2 id="railtieslibrailscommandsrb">railties/lib/rails/commands.rb</h2>

<p>这里看看 启动server的片段</p>

<p>```ruby
when ‘server’
  # Change to the application’s path if there is no config.ru file in current dir.
  # This allows us to run script/rails server from other directories, but still get
  # the main config.ru and properly set the tmp directory.
  Dir.chdir(File.expand_path(‘../../’, APP_PATH)) unless File.exists?(File.expand_path(“config.ru”))</p>

<p>require ‘rails/commands/server’
  Rails::Server.new.tap { |server|
    # We need to require application after the server sets environment,
    # otherwise the –environment option given to the server won’t propagate.
    require APP_PATH
    Dir.chdir(Rails.application.root)
    server.start
  }
```
这里最主要的就是调用了 	<code>rails/commnads/server</code> 该文件里定义了 server.start 方法。</p>

<h2 id="railtieslibrailscommandsserverrb">railties/lib/rails/commands/server.rb</h2>

<p>这个文件里主要是在 initialize的时候设置sever 的一些参数，再就是start</p>

<p>```ruby
 def start
      url = “#{options[:SSLEnable] ? ‘https’ : ‘http’}://#{options[:Host]}:#{options[:Port]}”
      puts “=&gt; Booting #{ActiveSupport::Inflector.demodulize(server)}”
      puts “=&gt; Rails #{Rails.version} application starting in #{Rails.env} on #{url}”
      puts “=&gt; Call with -d to detach” unless options[:daemonize]
      trap(:INT) { exit }
      puts “=&gt; Ctrl-C to shutdown server” unless options[:daemonize]</p>

<pre><code>  #Create required tmp directories if not found
  %w(cache pids sessions sockets).each do |dir_to_make|
    FileUtils.mkdir_p(Rails.root.join('tmp', dir_to_make))
  end

  super
ensure
  # The '-h' option calls exit before @options is set.
  # If we call 'options' with it unset, we get double help banners.
  puts 'Exiting' unless @options &amp;&amp; options[:daemonize]   end ``` 这时你就知道在 `rails s` 的时候显示的几行文字是从这里打印出来的了，最后他会调用 Rack::Server.start 方法，也就是父类方法.
</code></pre>

<h2 id="actionpacklibactiondispatchrb">actionpack/lib/action_dispatch.rb</h2>

<p>在 <code>server.rb</code> 里还require了 <code>action_dispatch</code>，这个文件在 Gem <code>action_pack</code> 目录下,
文件里引入了大部分rails需要的模块，包括：</p>

<p>```ruby
require ‘active_support’
require ‘active_support/dependencies/autoload’</p>

<p>require ‘action_pack’
require ‘active_model’
require ‘rack’
```
接下来就是rack server了</p>

<h2 id="racklibserverrb">rack/lib/server.rb</h2>

<p>rack 提供了统一的最简单的web server和应用程序之间的接口，所有的应用程序和web server都可以基于这个开发，大大节省了工作量和兼容问题，比如 rails 可以在自带的webserver webrick 跑，也可以在unicorn， thin，passanger 等webserver上跑，因为大家都是基于rack做的实现。</p>
]]></content>
  </entry>
  
</feed>
